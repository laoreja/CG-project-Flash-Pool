<html>

<head>
<title>Pool</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="data.js"></script>


<script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec2 vTextureCoord;
varying vec3 vTransformedNormal;
varying vec4 vPosition;

uniform vec3 uMaterialAmbientColor;
uniform vec3 uMaterialDiffuseColor;
uniform vec3 uMaterialSpecularColor;
uniform float uMaterialShininess;
uniform vec3 uMaterialEmissiveColor;

uniform bool uShowSpecularHighlights;
uniform bool uUseTextures;

uniform vec3 uAmbientLightingColor;

uniform vec3 uPointLightingLocation;
uniform vec3 uPointLightingDiffuseColor;
uniform vec3 uPointLightingSpecularColor;

uniform sampler2D uSampler;


void main(void) {
	vec3 ambientLightWeighting = uAmbientLightingColor;

	vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
	vec3 normal = normalize(vTransformedNormal);

	vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);
	if (uShowSpecularHighlights) {
		vec3 eyeDirection = normalize(-vPosition.xyz);
		vec3 reflectionDirection = reflect(-lightDirection, normal);

		float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
		specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;
	}

	float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);
	vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;

	vec3 materialAmbientColor = uMaterialAmbientColor;
	vec3 materialDiffuseColor = uMaterialDiffuseColor;
	vec3 materialSpecularColor = uMaterialSpecularColor;
	vec3 materialEmissiveColor = uMaterialEmissiveColor;
	float alpha = 1.0;
	if (uUseTextures) {
		vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
		materialAmbientColor = materialAmbientColor * textureColor.rgb;
		materialDiffuseColor = materialDiffuseColor * textureColor.rgb;
		materialEmissiveColor = materialEmissiveColor * textureColor.rgb;
		alpha = textureColor.a;
	}
	gl_FragColor = vec4(
		materialAmbientColor * ambientLightWeighting
		+ materialDiffuseColor * diffuseLightWeighting
		+ materialSpecularColor * specularLightWeighting
		+ materialEmissiveColor,
		alpha
	);
}
</script>

<script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat3 uNMatrix;

varying vec2 vTextureCoord;
varying vec3 vTransformedNormal;
varying vec4 vPosition;


void main(void) {
	vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
	gl_Position = uPMatrix * vPosition;
	vTextureCoord = aTextureCoord;
	vTransformedNormal = uNMatrix * aVertexNormal;
}
</script>


<script type="text/javascript">

	var gl;

	function initGL(canvas) {
			try {
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
			} catch (e) {
			}
			if (!gl) {
					alert("Could not initialise WebGL, sorry :-(");
			}
	}


	function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
					return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
					if (k.nodeType == 3) {
							str += k.textContent;
					}
					k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex") {
					shader = gl.createShader(gl.VERTEX_SHADER);
			} else {
					return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert(gl.getShaderInfoLog(shader));
					return null;
			}

			return shader;
	}


	var shaderProgram;

	function initShaders() {
		var fragmentShader = getShader(gl, "per-fragment-lighting-fs");
		var vertexShader = getShader(gl, "per-fragment-lighting-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
		gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");

		shaderProgram.materialAmbientColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialAmbientColor");
		shaderProgram.materialDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialDiffuseColor");
		shaderProgram.materialSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialSpecularColor");
		shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
		shaderProgram.materialEmissiveColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialEmissiveColor");
		shaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(shaderProgram, "uShowSpecularHighlights");
		shaderProgram.useTexturesUniform = gl.getUniformLocation(shaderProgram, "uUseTextures");
		shaderProgram.ambientLightingColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientLightingColor");
		shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
		shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
		shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
	}


		var mvMatrix = mat4.create();
		var mvMatrixStack = [];
		var pMatrix = mat4.create();

		function mvPushMatrix() {
				var copy = mat4.create();
				mat4.set(mvMatrix, copy);
				mvMatrixStack.push(copy);
		}

		function mvPopMatrix() {
				if (mvMatrixStack.length == 0) {
						throw "Invalid popMatrix!";
				}
				mvMatrix = mvMatrixStack.pop();
		}


		function setMatrixUniforms() {
				gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
				var normalMatrix = mat3.create();
				mat4.toInverseMat3(mvMatrix, normalMatrix);
				mat3.transpose(normalMatrix);
				gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);

		}

		function degToRad(degrees) {
				return degrees * Math.PI / 180;
		}

		var xRot = 0;
		var yRot = 0;
		var zRot = 0;
		
		var cubeVertexPositionBuffer = new Array(poolMTLNumMaterials);
		var cubeVertexNormalBuffer = new Array(poolMTLNumMaterials);
		var cubeVertexTextureCoordBuffer = new Array(poolMTLNumMaterials);
		var cubeVertexIndexBuffer = new Array(poolMTLNumMaterials);
		
		var vertices = new Array(poolMTLNumMaterials);
		var vertexNormals = new Array(poolMTLNumMaterials);
		var textureCoords = new Array(poolMTLNumMaterials);
		var cubeVertexIndices = new Array(poolMTLNumMaterials);
		
		function initBuffers() {
			for (var i = 0; i < poolMTLNumMaterials; i++) {
				cubeVertexPositionBuffer[i] = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[i]);
				vertices[i] = poolOBJVerts.slice(poolMTLFirst[i] * 3, (poolMTLFirst[i] + poolMTLCount[i]) * 3);

				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices[i]), gl.STATIC_DRAW);
				cubeVertexPositionBuffer[i].itemSize = 3;
				cubeVertexPositionBuffer[i].numItems = poolMTLCount[i];

				cubeVertexNormalBuffer[i] = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[i]);
				vertexNormals[i] = poolOBJNormals.slice(poolMTLFirst[i] * 3, (poolMTLFirst[i] + poolMTLCount[i]) * 3);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals[i]), gl.STATIC_DRAW);
				cubeVertexNormalBuffer[i].itemSize = 3;
				cubeVertexNormalBuffer[i].numItems = poolMTLCount[i];

				cubeVertexTextureCoordBuffer[i] = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[i]);
				textureCoords[i] = poolOBJTexCoords.slice(poolMTLFirst[i] * 2, (poolMTLFirst[i] + poolMTLCount[i]) * 2);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords[i]), gl.STATIC_DRAW);
				cubeVertexTextureCoordBuffer[i].itemSize = 2;
				cubeVertexTextureCoordBuffer[i].numItems = poolMTLCount[i];
	

				cubeVertexIndexBuffer[i] = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[i]);

				cubeVertexIndices[i] = new Array();
				for (var j = 0; j < poolMTLCount[i]; j++) {
					cubeVertexIndices[i].push(j);
				}
				
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices[i]), gl.STATIC_DRAW);
				cubeVertexIndexBuffer[i].itemSize = 1;
				cubeVertexIndexBuffer[i].numItems = poolMTLCount[i];
			}

			console.log(cubeVertexPositionBuffer[0]);		
			console.log(cubeVertexNormalBuffer[0]);
			console.log(cubeVertexTextureCoordBuffer[0]);
			console.log(cubeVertexIndexBuffer[0]);
		}


		function drawScene() {
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

				mat4.identity(mvMatrix);
				
				
				
				
				mvPushMatrix();
				
				mat4.translate(mvMatrix, [0.0, 0.0, -3.0]);

				mat4.rotate(mvMatrix, degToRad(xRot), [1, 0, 0]);
				mat4.rotate(mvMatrix, degToRad(yRot), [0, 1, 0]);
				mat4.rotate(mvMatrix, degToRad(zRot), [0, 0, 1]);
				
				gl.uniform1i(shaderProgram.showSpecularHighlightsUniform, true);
				gl.uniform3f(shaderProgram.pointLightingLocationUniform, -1, 2, -1);

				gl.uniform3f(shaderProgram.ambientLightingColorUniform, 0.2, 0.2, 0.2);
				gl.uniform3f(shaderProgram.pointLightingDiffuseColorUniform, 0.8, 0.8, 0.8);
				gl.uniform3f(shaderProgram.pointLightingSpecularColorUniform, 0.8, 0.8, 0.8);
				

				for (var i = 0; i < poolMTLNumMaterials; i++) {
					gl.uniform3f(shaderProgram.materialAmbientColorUniform, poolMTLAmbient[i*3], poolMTLAmbient[i*3+1], poolMTLAmbient[i*3+2]);
					gl.uniform3f(shaderProgram.materialDiffuseColorUniform, poolMTLDiffuse[i*3], poolMTLDiffuse[i*3+1], poolMTLDiffuse[i*3+2]);
					gl.uniform3f(shaderProgram.materialSpecularColorUniform, poolMTLSpecular[i*3], poolMTLSpecular[i*3+1], poolMTLSpecular[i*3+2]);
					gl.uniform1f(shaderProgram.materialShininessUniform, 2);
					gl.uniform3f(shaderProgram.materialEmissiveColorUniform, 0, 0, 0);
					gl.uniform1i(shaderProgram.useTexturesUniform, false);

					// now to render the mesh
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[i]);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer[i].itemSize, gl.FLOAT, false, 0, 0);

					gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);

					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[i]);
					gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer[i].itemSize	, gl.FLOAT, false, 0, 0);


					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[i]);
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[i].numItems, gl.UNSIGNED_SHORT, 0);
				}
				mvPopMatrix();
		}


		var lastTime = 0;

		function animate() {
				var timeNow = new Date().getTime();
				if (lastTime != 0) {
						var elapsed = timeNow - lastTime;

						xRot += (30 * elapsed) / 1000.0;
						yRot += (30 * elapsed) / 1000.0;
						zRot += (30 * elapsed) / 1000.0;
				}
				lastTime = timeNow;
		}

		function tick() {
				requestAnimFrame(tick);
				drawScene();
				animate();
		}

		
		function webGLStart(meshes) {
				console.log("in webgl start");
				var canvas = document.getElementById("lesson05-canvas");
				initGL(canvas);
				
				initShaders();
				initBuffers();

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
	
				tick();
		}
		
</script>


</head>


<body onload="webGLStart();">

		<canvas id="lesson05-canvas" style="border: none;" width="1000" height="800"></canvas>

</body>

</html>
